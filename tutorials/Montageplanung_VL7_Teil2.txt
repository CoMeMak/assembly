Das Diagramm bietet einen groben Überblick über verschiedene Möglichkeiten, einen Roboter zu programmieren. Ältere Roboterprogrammierumgebungen sowie die meisten offenen Programmierumgebungen bauen auf textbasierter Programmsemantik auf. Dies ist für Experten meistens die bevorzugte Art der Programmierung. Unter Programmsemantik (oder einfach Semantik) versteht man die Darstellung des logischen Aufbaus eines Programms. Programmiersprache und Programmsemantik bilden zusammen ein Programmiermodell. Im Gegensatz zur Ausführung eines Programms, die von der Computerarchitektur abhängig ist, kann seine Darstellung von einer Programmsemantik zu einer anderen unterschiedlich sein. Auch textbasierte Programmierumgebungen können auf unterschiedliche Semantiken aufbauen, wobei es immer eine gewisse Untermenge an gemeinsamen Elementen gibt, etwa Befehle, Funktionen, Zuweisungen, und so weiter. Größere semantische Unterschiede tauchen erst bei visuellen oder graphischen Programmierumgebungen auf. Im Falle der Roboterprogrammierung, sind die sogenannten Blockbasierten (oder Workflow) Programmiermodelle recht weit verbreitet. Diese werde wir uns später näher anschauen.

Aus dem Gesichtspunkt der Offenheit, unterscheidet man auch hier zwischen offene und proprietäre Programmierumgebungen. Wenn die Umgebung proprietär ist, dann ist meistens auch die Programmiersprache proprietär. Dies erfordert das Erlernen einer Programmiersprache zum Zweck der Programmierung von Robotern eines einzigen Herstellers. Obwohl dieses Modell durch offene Programmiersprachen ersetzt wird, werden von Roboterherstellern immer noch neue Roboterprogrammiersprachen erfunden, um das eigene Schulungsgeschäft auszubauen. Meistens wird dabei der Roboter an sich relativ günstig verkauft, in der Hoffnung, dass die Kunden dann auch Schulungen und Softwareerweiterungen dazukaufen. Der Preis eines Robotersystems wird deswegen oft direkt mit dem Kunden verhandelt.

Das Bild zeigt auch einige Roboter-Beispiele mit Bezug auf die unterschiedlichen Merkmale ihrer Programmierumgebungen.

RoboDK und ROS stellen zwei Ausnahmen dar. 

RoboDK ist eine hybride Umgebung, die eine Mischung zwischen textueller und visueller Programmierung bietet. Ähnlich wie beim Universal Robots Polyscope (hier nicht dargestellt), sind RoboDK-Programme semantisch wie textuelle Programme aufgebaut, wobei jedes Programmelement per Maus-Click manipuliert werden kann. Dieses Programmiermodell entstammt dem Versuch, zwei Welten zu vereinen, mit dem Vorteil, dass man relativ komplexe Programme erstellen kann, ohne die Syntax einer textuellen Programmierumgebung beherrschen zu müssen. Ein Nachteil dieses Programmiermodells ergibt sich aufgrund der langen Zeitdauer, die das Programmieren erfordert. Ähnlich wie ROS unterstützt auch RoboDK eine Vielzahl von Robotertypen unterschiedlicher Hersteller. Für jeden unterstützten Robotertyp bietet RoboDK auch ein Simulationsmodell an. Zum jeweiligen Robotermodell kann man auch weitere Gegenstände hinzufügen, wie etwa Werkstücke, welche vom Roboter manipuliert werden können. Anhand des Simulators können Programme durchgespielt werden. Anschließend können die Programme anhand des Roboters getestet werden. Dafür kann RoboDK die Programme in die für die verschiedenen Robotertypen notwendigen Dateiformate exportieren. RoboDK wir hauptsächlich für offline-Programmierung eingesetzt, wofür ein Simulator auch sinvoll ist. Im Gegensatz zur online-Programmierung, bei der das Roboterprogramm anhand eines sogenannten Teach Pendant erfolgt, werden im Falle der online-Programmierung Programme zuerst in einem Simulator durchgespielt, bevor sie am Roboter getestet werden.

Ein Beispiel für online-Programmierung (nicht zu verwechseln mit web-Programmierung) stellt die Polyscope-Programmierumgebung der Universal Robots dar. Der Roboter wird mittels eines Teach Pendants programmiert, das direkt mit dem Roboter über eine proprietäre Kabelverbindung gekoppelt ist. Die Mensch-Maschine Schnittstelle des Roboters ist eine graphische Benutzerschnittstelle, die Konfigurations- und Programmierfunktionen bietet. Das Bild zeigt auch, dass Polyscope-Programme ähnlich wie RoboDK-Programme aufgebaut sind. Die Programmierung im Polyscope nimmt ebenfalls viel Zeit in Anspruch und stößt an Grenzen, die nur durch textuelle Programmierung überwunden werden können. Polyscope ist eine proprietäre Software und kann somit nur von Entwicklern der Firma Universal Robots oder von  im UR+ Ökosystem zugelassenen Firmen erweitert werden.

Das sogenannte Robot Operating System (ROS) ist eine populäre "open source" textuelle Roboterprogrammierumgebung, die als Robotik-Middleware bezeichnet werden kann. Eine Robotik-Middleware ist eine zusammenhängende Sammlung von Softwarepaketen, die nützliche Funktionen auf der Ebene der Hardware und Kinematik bietet. ROS baut auf das sogenannte "Publish-Subscribe" Kommunikationsmuster, in welchem ein Gerät (beispielsweise ein Roboter oder eine Roboterkomponente) die Nachrichten anderer Geräte abboniert und in annähernder Echtzeit empfängt. Diese Nachrichten können beispielsweise Befehle oder Sensordaten enthalten und werden entweder Zeit- oder Ereignisgesteuert versendet. Die Publish-Subscribe Kommunikation hat einige Vorteile gegenüber der Client-Server Architektur, insbesondere in Bereich der Sicherheit und Echtzeitfähigkeit. Ein Nachteil ist aber, dass Publish-Subscribe Systeme schwieriger zu implementieren und analysieren sind, insbesondere in der Test und Integrationsphase. Ähnlich wie RoboDK unterstützt ROS auch viele Robotertypen. Eine in industriellen Kontexten einsatzfähige Version von ROS wird durch das ROS-Industrial Konsortium erstrebt. Dieses Konsortium setzt sich als Ziel, ROS industrietauglich durch die Verbesserung der nichtfunktionalen Qualitätsattribute der Software, etwa Performance, Skalierbarkeit, Sicherheit oder Echtzeitfähigkeit. ROS bietet auch anbindungen zu zwei populäre Robotersimulationsumgebungen, Gazebo und RVIS. Zusätzlich gibt es Pakete für maschinelles Lernen, Computer Vision und Pfadplanung, die allerdings unabhängig entwickelt werden und in ROS mittels der Publish-Subscribe Kommunikation integriert werden. Einige Nachteile von ROS sind, dass es fortgeschrittene Programmierkenntnisse sowie einen hohen Konfigurationsmehraufwand erfordert. Zudem ist die Pfadplanung nicht immer zuverlässig. ROS bietet einen Mehrwert für Experten mit fortgeschrittenen Programmierfähigkeiten, die ein Interesse an der Robotik haben. Für Endanwender bleibt ROS meistens unsichtbar und kann sehr wohl durch andere Softwarepakete ersetzt werden.

Welche sind die Vor- und Nachteile von proprietären Roboter-Programmierumgebungen? Die meisten Roboterhersteller entwickeln eigene, proprietäre Programmierumgebungen weil sie somit ihre Kunden festbinden können. Mit der Zeit erweisen sich solche Programmierumgebungen als zuverlässig (zum Beispiel im Vergleich zu ROS). Außerdem werden meistens vereinfachte Programmiermodelle implementiert, die die Funktionsbibliotheken und Programmstrukturen auf das Wesentliche reduzieren. Weitere Vorteile sind die gute Integration mit der Hardware sowie gute Teach-In Möglichkeiten und eine zuverlässige Pfadplanung.




 
