Das Diagramm bietet einen groben Überblick über verschiedene Möglichkeiten, einen Roboter zu programmieren. Ältere Roboterprogrammierumgebungen sowie die meisten offenen Programmierumgebungen bauen auf textbasierter Programmsemantik auf. Dies ist für Experten meistens die bevorzugte Art der Programmierung. Unter Programmsemantik (oder einfach Semantik) versteht man die Darstellung des logischen Aufbaus eines Programms. Programmiersprache und Programmsemantik bilden zusammen ein Programmiermodell. Im Gegensatz zur Ausführung eines Programms, die von der Computerarchitektur abhängig ist, kann seine Darstellung von einer Programmsemantik zu einer anderen unterschiedlich sein. Auch textbasierte Programmierumgebungen können auf unterschiedliche Semantiken aufbauen, wobei es immer eine gewisse Untermenge an gemeinsamen Elementen gibt, etwa Befehle, Funktionen, Zuweisungen, und so weiter. Größere semantische Unterschiede tauchen erst bei visuellen oder graphischen Programmierumgebungen auf. Im Falle der Roboterprogrammierung, sind die sogenannten Blockbasierten (oder Workflow) Programmiermodelle recht weit verbreitet. Diese werden wir uns später näher anschauen.

Aus dem Gesichtspunkt der Offenheit, unterscheidet man auch hier zwischen offene und proprietäre Programmierumgebungen. Wenn die Umgebung proprietär ist, dann ist meistens auch die Programmiersprache proprietär. Dies erfordert seitens der Endanwender das Erlernen einer Programmiersprache zum Zweck der Programmierung von Robotern eines einzigen Herstellers. 

Das Bild zeigt auch einige Roboter-Beispiele in Bezug auf die unterschiedlichen Merkmale ihrer Programmierumgebungen.

RoboDK und ROS stellen zwei Ausnahmen im Vergleich zu den meisten anderen Roboter-Programmierumgebungen dar, weil sie eine vielzahl von Robotern unterstützen. Man redet hier über generalisierte Roboterprogrammierung, was in der Robotikwelt sehr erwünscht ist. Dabei verwendet auch RoboDK ein proprietäres Programmiermodell. 

RoboDK ist eine hybride Umgebung, die auf eine Mischung von textueller und visueller Programmierung aufsetzt. Ähnlich wie beim Universal Robots Polyscope (darüber gleich mehr in der nächsten Folie), sind RoboDK-Programme semantisch wie textuelle Programme aufgebaut, wobei jedes Programmelement per Maus-Click manipuliert werden kann. Dieses Programmiermodell entstammt dem Versuch, zwei Welten zu vereinen, mit dem Vorteil, dass man relativ komplexe Programme erstellen kann, ohne die Syntax einer textuellen Programmiersprache beherrschen zu müssen. Ein Nachteil dieses Programmiermodells ergibt sich aufgrund der langen Zeitdauer, die das Programmieren erfordert. Ähnlich wie ROS unterstützt auch RoboDK eine Vielzahl von Robotertypen unterschiedlicher Hersteller. Für jeden unterstützten Robotertyp bietet RoboDK auch ein Simulationsmodell. In der Simulation kann der Roboter mit weiteren Gegenständen interagieren, wie etwa Werkstücke, welche vom Roboter manipuliert werden können. Anhand des Simulators können Programme durchgespielt werden bevor sie anhand des Roboters getestet werden. RoboDK kann Programme in die für die verschiedenen Robotertypen notwendigen Dateiformate exportieren. RoboDK wir hauptsächlich für offline-Programmierung eingesetzt, wofür ein Simulator auch sinnvoll ist. Im Gegensatz zur online-Programmierung, bei der das Roboterprogramm anhand eines sogenannten Teach Pendant erstellt wird, werden im Falle der offline-Programmierung Programme meist zuerst in einem Simulator durchgespielt, bevor sie am Roboter getestet werden.

Ein Beispiel für online-Programmierung (nicht zu verwechseln mit web-Programmierung) stellt die Polyscope-Programmierumgebung der Universal Robots dar. Der Roboter wird mittels eines Teach Pendants programmiert, das direkt mit dem Roboter über eine proprietäre Kabelverbindung gekoppelt ist. Die Mensch-Maschine Schnittstelle des Roboters ist eine graphische Benutzerschnittstelle, die Konfigurations- und Programmierfunktionen bietet. Das Bild zeigt auch, dass Polyscope-Programme ähnlich wie RoboDK-Programme aufgebaut sind. Die Programmierung im Polyscope nimmt ebenfalls viel Zeit in Anspruch und stößt an Grenzen, die nur durch textuelle Programmierung überwunden werden können. Polyscope ist eine proprietäre Software und kann somit nur von Entwicklern der Firma Universal Robots oder von  im UR+ Ökosystem zugelassenen Firmen erweitert werden.

Das sogenannte Robot Operating System (ROS) ist eine populäre "open source" textuelle Roboterprogrammierumgebung, die als Robotik-Middleware bezeichnet werden kann. Eine Robotik-Middleware ist eine zusammenhängende Sammlung von Softwarepaketen, die nützliche Funktionen auf der Ebene der Hardware und Kinematik bietet. ROS baut auf das sogenannte "Publish-Subscribe" Kommunikationsmuster, in welchem ein Gerät (beispielsweise ein Roboter oder eine Roboterkomponente) die Nachrichten anderer Geräte abonniert und in annähernder Echtzeit empfängt. Diese Nachrichten können beispielsweise Befehle oder Sensordaten enthalten und werden entweder Zeit- oder Ereignisgesteuert versendet. Die Publish-Subscribe Kommunikation hat einige Vorteile gegenüber der Client-Server Architektur, insbesondere in Bereich der Sicherheit und Echtzeitfähigkeit. Ein Nachteil ist aber, dass Publish-Subscribe Systeme schwieriger zu implementieren und analysieren sind, insbesondere in der Test und Integrationsphase. Ähnlich wie RoboDK unterstützt ROS auch viele Robotertypen. Eine in industriellen Kontexten einsatzfähige Version von ROS wird durch das ROS-Industrial Konsortium erstrebt. Dieses Konsortium setzt sich als Ziel, ROS industrietauglich durch die Verbesserung der nichtfunktionalen Qualitätsattribute der Software, etwa Performance, Skalierbarkeit, Sicherheit oder Echtzeitfähigkeit. ROS bietet auch Anbindungen zu zwei populäre Robotersimulationsumgebungen, Gazebo und RVIS. Zusätzlich gibt es Pakete für maschinelles Lernen, Computer Vision und Pfadplanung, die allerdings unabhängig entwickelt werden und in ROS mittels der Publish-Subscribe Kommunikation integriert werden. Einige Nachteile von ROS sind, dass es fortgeschrittene Programmierkenntnisse sowie einen hohen Konfigurationsmehraufwand erfordert. Zudem ist die Pfadplanung nicht immer zuverlässig. ROS bietet einen Mehrwert für Experten mit fortgeschrittenen Programmierfähigkeiten, die ein Interesse an der Robotik haben. Für Endanwender bleibt ROS meistens unsichtbar und kann sehr wohl durch andere Softwarepakete ersetzt werden.

Welche sind die Vor- und Nachteile von proprietären Roboter-Programmierumgebungen? Die meisten Roboterhersteller entwickeln eigene, proprietäre Programmierumgebungen weil sie somit ihre Kunden festbinden können. Mit der Zeit erweisen sich solche Programmierumgebungen als zuverlässig (zum Beispiel im Vergleich zu ROS). Außerdem werden meistens vereinfachte Programmiermodelle implementiert, die die Funktionsbibliotheken und Programmstrukturen auf das Wesentliche reduzieren. Weitere Vorteile sind die gute Integration mit der Hardware sowie gute Teach-In Möglichkeiten und eine zuverlässige Pfadplanung.

Einige Nachteile proprietärer Programmierumgebungen ergeben sich aus der Tatsachte, dass ein Vendor Lock-In wahrscheinlicher wird und das die Interoperabilität der Software mit anderen Software-Bibliotheken wird von Herstellern kontrolliert wird. Die Möglichkeiten zur Vernetzung mit anderen Systemen sind meistens nur über HW-Protokolle wie OPC UA oder MODBUS möglich, was höhere Entwicklungskosten verursachen kann. Die von den Herstellern angebotenen Schulungen sind nicht immer günstig. Und um Kundschaft für Schulungen zu gewinnen, verbreiten die Anbieter nur spärlich Dokumentation im Internet.

Offene Roboter-Programmierumgebungen überwinden einige der Nachteile der proprietären Programmierumgebungen. Allerdings gibt es derzeit wenige offene, kostenlose Programmierumgebungen für Endbenutzer. Offene Programmierumgebungen werden durch die Open Source Community erweitert und gewartet. Dabei ist der Quellcode offen und kostenlos, sodass man als Entwickler die volle Kontrolle über alle Funktionen hat. Leider sind offene Roboter-Programmierumgebungen, wie ROS, oft benutzerunfreundlich und erfordern fortgeschrittenen Programmierkenntnisse. Zusätzlich gibt es keinen Kundensupport und die Kompatibilität mit verschiedenen Robotertypen und Endeffektoren lässt auch zu wünschen.
