Das Diagramm bietet einen groben Überblick über verschiedene Möglichkeiten, einen Roboter zu programmieren. Ältere Roboterprogrammierumgebungen sowie die meisten offenen Programmierumgebungen bauen auf textbasierter Programmsemantik auf. Dies ist für Experten meistens die bevorzugte Art der Programmierung. Unter Programmsemantik (oder einfach Semantik) versteht man die Darstellung des logischen Aufbaus eines Programms. Programmiersprache und Programmsemantik bilden zusammen ein Programmiermodell. Im Gegensatz zur Ausführung eines Programms, die von der Computerarchitektur abhängig ist, kann seine Darstellung von einer Programmsemantik zu einer anderen unterschiedlich sein. Auch textbasierte Programmierumgebungen können auf unterschiedliche Semantiken aufbauen, wobei es immer eine gewisse Untermenge an gemeinsamen Elementen gibt, etwa Befehle, Funktionen, Zuweisungen, und so weiter. Größere semantische Unterschiede tauchen erst bei visuellen oder graphischen Programmierumgebungen auf. Im Falle der Roboterprogrammierung, sind die sogenannten Blockbasierten (oder Workflow) Programmiermodelle recht weit verbreitet. Diese werden wir uns später näher anschauen.

Aus dem Gesichtspunkt der Offenheit, unterscheidet man auch hier zwischen offene und proprietäre Programmierumgebungen. Wenn die Umgebung proprietär ist, dann ist meistens auch die Programmiersprache proprietär. Dies erfordert seitens der Endanwender das Erlernen einer Programmiersprache zum Zweck der Programmierung von Robotern eines einzigen Herstellers. 

Das Bild zeigt auch einige Roboter-Beispiele in Bezug auf die unterschiedlichen Merkmale ihrer Programmierumgebungen.

RoboDK und ROS stellen zwei Ausnahmen im Vergleich zu den meisten anderen Roboter-Programmierumgebungen dar, weil sie eine vielzahl von Robotern unterstützen. Man redet hier über generalisierte Roboterprogrammierung, was in der Robotikwelt sehr erwünscht ist. Dabei verwendet auch RoboDK ein proprietäres Programmiermodell. 

RoboDK ist eine hybride Umgebung, die auf eine Mischung von textueller und visueller Programmierung aufsetzt. Ähnlich wie beim Universal Robots Polyscope (darüber gleich mehr in der nächsten Folie), sind RoboDK-Programme semantisch wie textuelle Programme aufgebaut, wobei jedes Programmelement per Maus-Click manipuliert werden kann. Dieses Programmiermodell entstammt dem Versuch, zwei Welten zu vereinen, mit dem Vorteil, dass man relativ komplexe Programme erstellen kann, ohne die Syntax einer textuellen Programmiersprache beherrschen zu müssen. Ein Nachteil dieses Programmiermodells ergibt sich aufgrund der langen Zeitdauer, die das Programmieren erfordert. Ähnlich wie ROS unterstützt auch RoboDK eine Vielzahl von Robotertypen unterschiedlicher Hersteller. Für jeden unterstützten Robotertyp bietet RoboDK auch ein Simulationsmodell. In der Simulation kann der Roboter mit weiteren Gegenständen interagieren, wie etwa Werkstücke, welche vom Roboter manipuliert werden können. Anhand des Simulators können Programme durchgespielt werden bevor sie anhand des Roboters getestet werden. RoboDK kann Programme in die für die verschiedenen Robotertypen notwendigen Dateiformate exportieren. RoboDK wir hauptsächlich für offline-Programmierung eingesetzt, wofür ein Simulator auch sinnvoll ist. Im Gegensatz zur online-Programmierung, bei der das Roboterprogramm anhand eines sogenannten Teach Pendant erstellt wird, werden im Falle der offline-Programmierung Programme meist zuerst in einem Simulator durchgespielt, bevor sie am Roboter getestet werden.

Ein Beispiel für eine online-Programmierumgebung stellt "Polyscope", die von Universal Robots entwickelte proprietäre Mensch-Maschine Schnittstelle dar. Der Roboter wird mittels eines Teach Pendants programmiert, das direkt mit dem Roboter über eine Kabelverbindung gekoppelt ist. Die Mensch-Maschine Schnittstelle des Roboters ist eine graphische Benutzerschnittstelle, die Konfigurations- und Programmierfunktionen unterstützt. Wie das Bild zeigt, sind Polyscope-Programme ähnlich wie RoboDK-Programme aufgebaut. Die Programmierung in Polyscope nimmt ebenfalls viel Zeit in Anspruch und stößt an Grenzen, die nur durch textuelle Programmierung überwunden werden können. Polyscope ist eine proprietäre Software und kann somit nur von Entwicklern der Firma Universal Robots oder von  im UR+ Ökosystem zugelassenen Firmen erweitert werden.

Das sogenannte Robot Operating System (ROS) ist eine populäre, offene textuelle Roboterprogrammierumgebung, die oft auch als Robotik-Middleware bezeichnet wird. Eine Robotik-Middleware ist eine zusammenhängende Sammlung von Softwarepaketen, die nützliche Funktionen auf der Ebene der Hardware und Kinematik bieten. ROS baut auf das sogenannte "Publish-Subscribe" Kommunikationsmuster auf, in welchem ein Gerät (beispielsweise ein Roboter oder eine Roboterkomponente) Nachrichten anderer Geräte abonniert und in annähernder Echtzeit empfängt. Diese Nachrichten können beispielsweise Befehle oder Sensordaten enthalten und werden entweder eeit- oder ereignisgesteuert versendet. Die Publish-Subscribe Kommunikation hat einige Vorteile, insbesondere im Bereich der Sicherheit und Echtzeitfähigkeit. Ein Nachteil ist aber, dass Publish-Subscribe Systeme schwieriger zu implementieren und analysieren sind, insbesondere in der Test und Integrationsphase. Ähnlich wie RoboDK unterstützt ROS auch viele Robotertypen. Eine in industriellen Kontexten einsatzfähige Version von ROS wird durch das ROS-Industrial Konsortium entwickelt. Dieses Konsortium setzt sich als Ziel, ROS industrietauglich durch die Verbesserung der nichtfunktionalen Qualitätsattribute der Software zu machen, etwa der Performance, Skalierbarkeit, Sicherheit und Echtzeitfähigkeit der Softwarekomponenten. ROS bietet auch Anbindungen zu zwei populäre Robotersimulationsumgebungen, Gazebo und RVIS. Zusätzlich gibt es Pakete für maschinelles Lernen, Computer Vision und Pfadplanung, die allerdings unabhängig entwickelt werden und in ROS lediglich integriert werden. Einige Nachteile von ROS sind, dass es fortgeschrittene Programmierkenntnisse sowie einen hohen Konfigurationsmehraufwand erfordert. Zudem ist die Pfadplanung nicht immer zuverlässig. ROS bietet somit hauptsächlich einen Mehrwert für Experten mit fortgeschrittenen Programmierfähigkeiten, die ein Interesse an der Robotik haben. Für Endanwender bleibt ROS meistens unsichtbar und kann sehr wohl durch andere Softwarepakete ersetzt werden.

Welche sind die Vor- und Nachteile von proprietären Roboter-Programmierumgebungen? Die meisten Roboterhersteller entwickeln eigene, proprietäre Programmierumgebungen, weil sie somit ihre Kunden festbinden können, aber auch weil sie mehr Freiheit haben, eigene Ideen und Programmiermodelle umzusetzen. Mit der Zeit erweisen sich solche Programmierumgebungen als zuverlässig. Außerdem werden meistens vereinfachte Programmiermodelle implementiert, die die Funktionsbibliotheken und Programmstrukturen auf das Wesentliche reduzieren, was zur erleichterung von Programmieraufgaben beiträgt. Weitere Vorteile sind etwa gute Teach-In Möglichkeiten und eine zuverlässige Pfadplanung.

Einige Nachteile proprietärer Programmierumgebungen ergeben sich aus der Tatsachte, dass ein Vendor Lock-In wahrscheinlicher wird und dass die Interoperabilität der Software mit dritten Software-Bibliotheken nicht immer gegeben ist. Die Möglichkeiten zur Vernetzung mit anderen Systemen sind meistens nur über Hardware-Protokolle wie OPC UA oder MODBUS möglich, was höhere Entwicklungskosten verursachen kann. Dazu kommt noch, dass die von den Herstellern angebotenen Schulungen nicht immer günstig sind; und dass die Anbieter nur spärlich Dokumentation im Internet verbreiten, um neue Kundschaft für Schulungen zu gewinnen.

Offene Roboter-Programmierumgebungen überwinden einige der Nachteile der proprietären Programmierumgebungen. Allerdings gibt es derzeit wenige offene, kostenlose Roboter-Programmierumgebungen für Endbenutzer. Offene Programmierumgebungen werden durch die Open Source Community entwickelt, erweitert und gewartet. Dabei ist der Quellcode offen und kostenlos, sodass man als Entwickler die volle Kontrolle über alle Funktionen hat. Leider sind offene Roboter-Programmierumgebungen, wie ROS, oft benutzerunfreundlich und erfordern fortgeschrittene Programmierkenntnisse. Zusätzlich gibt es keinen Kundensupport und die Kompatibilität mit verschiedenen Robotertypen und Endeffektoren lässt auch zu wünschen.
